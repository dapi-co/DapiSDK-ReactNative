package com.dapi;

import android.util.Log;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.facebook.react.bridge.Arguments;
import com.facebook.react.bridge.Callback;
import com.facebook.react.bridge.Dynamic;
import com.facebook.react.bridge.Promise;
import com.facebook.react.bridge.ReactApplicationContext;
import com.facebook.react.bridge.ReactContext;
import com.facebook.react.bridge.ReactContextBaseJavaModule;
import com.facebook.react.bridge.ReactMethod;
import com.facebook.react.bridge.ReadableArray;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.bridge.WritableArray;
import com.facebook.react.bridge.WritableMap;
import com.facebook.react.bridge.WritableNativeArray;
import com.facebook.react.bridge.WritableNativeMap;
import com.facebook.react.module.annotations.ReactModule;
import com.facebook.react.modules.core.DeviceEventManagerModule;
import com.google.gson.Gson;

import org.json.JSONException;
import org.json.JSONObject;

import java.lang.reflect.Array;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Locale;
import java.util.Objects;

import javax.annotation.Nonnull;

import co.dapi.connect.core.base.Dapi;
import co.dapi.connect.core.callbacks.DapiAccountSelectionCallback;
import co.dapi.connect.core.callbacks.DapiAccountSelectionResult;
import co.dapi.connect.core.callbacks.DapiConnectCallback;
import co.dapi.connect.core.callbacks.DapiConnectResult;
import co.dapi.connect.core.callbacks.DapiTransferCallback;
import co.dapi.connect.core.callbacks.DapiTransferResult;
import co.dapi.connect.data.endpoint_models.DapiAccountsResponse;
import co.dapi.connect.data.endpoint_models.DapiCardsResponse;
import co.dapi.connect.data.models.DapiBeneficiary;
import co.dapi.connect.data.models.DapiColor;
import co.dapi.connect.data.models.DapiConfigurations;
import co.dapi.connect.data.models.DapiConnection;
import co.dapi.connect.data.models.DapiEnvironment;
import co.dapi.connect.data.models.DapiError;
import co.dapi.connect.data.models.DapiLanguage;
import co.dapi.connect.data.models.DapiTheme;
import co.dapi.connect.data.models.DapiThemeConfigurations;
import co.dapi.connect.data.models.DapiTransactionsType;
import co.dapi.connect.data.models.DapiWireBeneficiary;
import co.dapi.connect.data.models.LinesAddress;
import kotlin.Unit;
import kotlin.jvm.functions.Function1;

@ReactModule(name = DapiConnectModule.NAME)
public class DapiConnectModule extends ReactContextBaseJavaModule {

    public static final String TAG = "DapiSDK";
    public static final String NAME = "DapiConnectManager";

    public static final String EVENT_CONNECT_SUCCESSFUL = "EventConnectSuccessful";
    public static final String EVENT_CONNECT_FAILURE = "EventConnectFailure";
    public static final String EVENT_CONNECT_DISMISSED = "EventConnectDismissed";
    public static final String EVENT_CONNECT_BANK_REQUEST = "EventConnectBankRequest";

    public static final String EVENT_DAPI_UI_WILL_TRANSFER = "EventDapiUIWillTransfer";
    public static final String EVENT_DAPI_TRANSFER_UI_DISMISSED = "EventDapiTransferUIDismissed";

    private static final String KEY_MESSAGE = "message";
    private static final String KEY_TYPE = "type";
    private static final String KEY_OPERATION_ID = "operationID";
    private static final String KEY_UNIT = "unit";
    private static final String KEY_VALUE = "value";
    private static final String KEY_ACCOUNT = "account";

    public DapiConnectModule(ReactApplicationContext reactContext) {
        super(reactContext);
    }

    @Nonnull
    @Override
    public String getName() {
        return NAME;
    }

    @ReactMethod
    public void start(String appKey, String clientUserID, ReadableMap configurationMap, Promise promise) {
        Dapi.start(
                Objects.requireNonNull(getCurrentActivity()).getApplication(),
                appKey,
                clientUserID,
                getConfigurations(configurationMap), () -> {
                    resolve(null, promise);
                    return Unit.INSTANCE;
                }, error -> {
                    reject(getErrorCode(error), error, promise);
                    return Unit.INSTANCE;
                }

        );
    }

    @ReactMethod
    public void isStarted(Promise promise) {
        resolve(Dapi.isStarted(), promise);
    }

    @ReactMethod
    public void presentConnect(String bankID) {
        Dapi.presentConnect(bankID);
        setConnectCallback();
    }

    @ReactMethod
    public void dismissConnect() {
        Dapi.dismissConnect();
    }

    @ReactMethod
    public void dismissTransfer() {
        Dapi.dismissTransfer();
    }

    @ReactMethod
    public void dismissMFA() {
        Dapi.dismissMFA();
    }

    @ReactMethod
    public void setClientUserID(String clientUserID) {
        Dapi.setClientUserID(clientUserID);
    }

    @ReactMethod
    public void clientUserID(Promise promise) {
        String clientUserID = Dapi.getClientUserID();
        resolve(clientUserID, promise);
    }

    @ReactMethod
    public void setConfigurations(ReadableMap configurationMap) {
        Dapi.setConfigurations(getConfigurations(configurationMap));
    }

    @ReactMethod
    public void configurations(Promise promise) {
        resolve(Dapi.getConfigurations(), promise);
    }

    @ReactMethod
    private void presentAccountSelection(String userID, Promise promise) {
        getOperatingConnection(userID, connection -> {
            connection.presentAccountSelection(new DapiAccountSelectionCallback() {
                @Override
                public void onSelected(@NonNull DapiAccountSelectionResult.Success successResult) {
                    resolve(successResult.getAccount().getId(), promise);
                }

                @Override
                public void onFailure(@NonNull DapiAccountSelectionResult.Error errorResult) {
                    reject(getErrorCode(errorResult.getError()), errorResult.getError(), promise);
                }

                @Override
                public void onDismissed() {
                    String message = "Account selection was cancelled";
                    DapiError error = new DapiError(DapiError.USER_CANCELLED, message, message, null, null, null);
                    reject(getErrorCode(error), error, promise);
                }
            });
            return Unit.INSTANCE;
        }, error -> {
            reject(getErrorCode(error), error, promise);
            return Unit.INSTANCE;
        });
    }

    @SuppressWarnings("ConstantConditions")
    @ReactMethod
    public void getConnections(Promise promise) {
        Dapi.getConnections(connections -> {
            WritableArray connectionsArray = new WritableNativeArray();
            for (DapiConnection connection : connections) {
                try {
                    WritableMap connectionMap = new WritableNativeMap();
                    connectionMap.putString("userID", connection.getUserID());
                    connectionMap.putString("clientUserID", connection.getClientUserID());
                    connectionMap.putString("bankID", connection.getBankId());
                    connectionMap.putString("swiftCode", connection.getSwiftCode());
                    connectionMap.putString("bankShortName", connection.getName());
                    connectionMap.putString("bankFullName", connection.getFullName());
                    connectionMap.putString("country", connection.getCountry());
                    connectionMap.putString("fullLogo", connection.getFullLogoPng());
                    connectionMap.putString("halfLogo", connection.getHalfLogoPng());
                    connectionMap.putString("miniLogo", connection.getMiniLogoPng());
                    connectionsArray.pushMap(connectionMap);
                } catch (Exception e) {
                    Log.e(TAG, e.toString());
                    reject("0", e.getMessage(), promise);
                }

            }
            resolve(connectionsArray, promise);
            return Unit.INSTANCE;
        }, error -> {
            reject(getErrorCode(error), error, promise);
            return Unit.INSTANCE;
        });
    }


    @ReactMethod
    public void getIdentity(String userID, Promise promise) {
        getOperatingConnection(userID, connection -> {
            connection.getIdentity(identity -> {
                resolve(identity, promise);
                return Unit.INSTANCE;
            }, error -> {
                reject(getErrorCode(error), error, promise);
                return Unit.INSTANCE;
            });
            return Unit.INSTANCE;
        }, error -> {
            reject(getErrorCode(error), error, promise);
            return Unit.INSTANCE;
        });
    }

    @ReactMethod
    public void getAccounts(String userID, Promise promise) {
        getOperatingConnection(userID, connection -> {
            connection.getAccounts(accounts -> {
                resolve(accounts, promise);
                return Unit.INSTANCE;
            }, error -> {
                reject(getErrorCode(error), error, promise);
                return Unit.INSTANCE;
            });
            return Unit.INSTANCE;
        }, error -> {
            reject(getErrorCode(error), error, promise);
            return Unit.INSTANCE;
        });
    }

    @ReactMethod
    public void getCards(String userID, Promise promise) {
        getOperatingConnection(userID, connection -> {
            connection.getCards(cards -> {
                resolve(cards, promise);
                return Unit.INSTANCE;
            }, error -> {
                reject(getErrorCode(error), error, promise);
                return Unit.INSTANCE;
            });
            return Unit.INSTANCE;
        }, error -> {
            reject(getErrorCode(error), error, promise);
            return Unit.INSTANCE;
        });
    }

    @ReactMethod
    public void getTransactionsForAccount(
            String userID,
            String accountID,
            Dynamic startDate,
            Dynamic endDate,
            String type,
            Promise promise
    ) {
        long startDateAsLong = (long) startDate.asDouble();
        long endDateAsLong = (long) endDate.asDouble();

        DapiTransactionsType nativeType;
        if (type.toLowerCase(Locale.ROOT).equals("enriched")) {
            nativeType = DapiTransactionsType.ENRICHED;
        } else if (type.toLowerCase(Locale.ROOT).equals("categorized")) {
            nativeType = DapiTransactionsType.CATEGORIZED;
        } else {
            nativeType = DapiTransactionsType.DEFAULT;
        }

        Date startDateObject = new Date(startDateAsLong);
        Date endDateObject = new Date(endDateAsLong);

        getOperatingConnection(userID, connection -> {
            DapiAccountsResponse.DapiAccount account = getDapiAccount(accountID, connection);

            if (account == null) {
                reject("1004", "Unable to find account with id " + accountID, promise);
                return Unit.INSTANCE;
            }

            connection.getTransactions(account, startDateObject, endDateObject, nativeType, transactions -> {
                resolve(transactions, promise);
                return Unit.INSTANCE;
            }, error -> {
                reject(getErrorCode(error), error, promise);
                return Unit.INSTANCE;
            });

            return Unit.INSTANCE;
        }, error -> {
            reject(getErrorCode(error), error, promise);
            return Unit.INSTANCE;
        });
    }

    @ReactMethod
    public void getTransactionsForCard(
            String userID,
            String cardID,
            Dynamic startDate,
            Dynamic endDate,
            String type,
            Promise promise
    ) {
        long startDateAsLong = (long) startDate.asDouble();
        long endDateAsLong = (long) endDate.asDouble();

        DapiTransactionsType nativeType;
        if (type.toLowerCase(Locale.ROOT).equals("enriched")) {
            nativeType = DapiTransactionsType.ENRICHED;
        } else if (type.toLowerCase(Locale.ROOT).equals("categorized")) {
            nativeType = DapiTransactionsType.CATEGORIZED;
        } else {
            nativeType = DapiTransactionsType.DEFAULT;
        }

        Date startDateObject = new Date(startDateAsLong);
        Date endDateObject = new Date(endDateAsLong);

        getOperatingConnection(userID, connection -> {
            DapiCardsResponse.DapiCard card = getDapiCard(cardID, connection);
            if (card == null) {
                reject("1005", "Unable to find card with id " + cardID, promise);
                return Unit.INSTANCE;
            }
            connection.getTransactions(card, startDateObject, endDateObject, nativeType, transactions -> {
                resolve(transactions, promise);
                return Unit.INSTANCE;
            }, error -> {
                reject(getErrorCode(error), error, promise);
                return Unit.INSTANCE;
            });
            return Unit.INSTANCE;
        }, error -> {
            reject(getErrorCode(error), error, promise);
            return Unit.INSTANCE;
        });
    }


    @ReactMethod
    public void getAccountsMetadata(String userID, Promise promise) {
        getOperatingConnection(userID, connection -> {
            connection.getAccountsMetaData(accountsMetaData -> {
                resolve(accountsMetaData, promise);
                return Unit.INSTANCE;
            }, error -> {
                reject(getErrorCode(error), error, promise);
                return Unit.INSTANCE;
            });
            return Unit.INSTANCE;
        }, error -> {
            reject(getErrorCode(error), error, promise);
            return Unit.INSTANCE;
        });
    }

    @ReactMethod
    public void delete(
            String userID,
            Promise promise
    ) {
        getOperatingConnection(userID, connection -> {
            connection.delete(delink -> {
                resolve(delink, promise);
                return Unit.INSTANCE;
            }, error -> {
                reject(getErrorCode(error), error, promise);
                return Unit.INSTANCE;
            });
            return Unit.INSTANCE;
        }, error -> {
            reject(getErrorCode(error), error, promise);
            return Unit.INSTANCE;
        });
    }

    @ReactMethod
    public void createTransfer(
            String userID,
            String accountID,
            ReadableMap beneficiaryMap,
            double amount,
            String remark,
            Promise promise
    ) {
        setTransferCallback(promise);
        getOperatingConnection(userID, connection -> {
            DapiAccountsResponse.DapiAccount account = getDapiAccount(accountID, connection);
            DapiBeneficiary beneficiary = getBeneficiary(beneficiaryMap);
            connection.createTransfer(account, beneficiary, amount, remark);
            return Unit.INSTANCE;
        }, error -> {
            reject(getErrorCode(error), error, promise);
            return Unit.INSTANCE;
        });
    }

    @ReactMethod
    public void createTransferToExistingBeneficiary(
            String userID,
            String accountID,
            String receiverID,
            double amount,
            String remark,
            Promise promise
    ) {
        setTransferCallback(promise);
        getOperatingConnection(userID, connection -> {
            DapiAccountsResponse.DapiAccount account = getDapiAccount(accountID, connection);

            if (account == null) {
                reject("1004", "Unable to find account with id " + accountID, promise);
                return Unit.INSTANCE;
            }

            connection.createTransferToExistingBeneficiary(account, receiverID, amount, remark);
            return Unit.INSTANCE;
        }, error -> {
            reject(getErrorCode(error), error, promise);
            return Unit.INSTANCE;
        });
    }

    @ReactMethod
    public void getBeneficiaries(String userID, Promise promise) {
        getOperatingConnection(userID, connection -> {
            connection.getBeneficiaries(beneficiaries -> {
                resolve(beneficiaries, promise);
                return Unit.INSTANCE;
            }, error -> {
                reject(getErrorCode(error), error, promise);
                return Unit.INSTANCE;
            });
            return Unit.INSTANCE;
        }, error -> {
            reject(getErrorCode(error), error, promise);
            return Unit.INSTANCE;
        });
    }

    @ReactMethod
    public void createBeneficiary(String userID, ReadableMap beneficiaryMap, Promise promise) {
        getOperatingConnection(userID, connection -> {
            DapiBeneficiary beneficiary = getBeneficiary(beneficiaryMap);

            if (beneficiary == null) {
                reject("2012", "Missing beneficiary required field", promise);
                return Unit.INSTANCE;
            }

            connection.createBeneficiary(beneficiary, createBeneficiary -> {
                resolve(createBeneficiary, promise);
                return Unit.INSTANCE;
            }, error -> {
                reject(getErrorCode(error), error, promise);
                return Unit.INSTANCE;
            });

            return Unit.INSTANCE;
        }, error -> {
            reject(getErrorCode(error), error, promise);
            return Unit.INSTANCE;
        });
    }


    @ReactMethod
    public void createWireTransfer(
            String userID,
            ReadableMap beneficiaryMap,
            String accountID,
            double amount,
            String remark,
            Promise promise
    ) {
        setTransferCallback(promise);
        getOperatingConnection(userID, connection -> {
            DapiAccountsResponse.DapiAccount account = getDapiAccount(accountID, connection);
            DapiWireBeneficiary beneficiary = getWireBeneficiary(beneficiaryMap);
            connection.createWireTransfer(beneficiary, account, amount, remark);
            return Unit.INSTANCE;
        }, error -> {
            reject(getErrorCode(error), error, promise);
            return Unit.INSTANCE;
        });
    }

    @ReactMethod
    public void createWireTransferToExistingBeneficiary(
            String userID,
            String accountID,
            String receiverID,
            double amount,
            String remark,
            Promise promise
    ) {
        setTransferCallback(promise);
        getOperatingConnection(userID, connection -> {
            DapiAccountsResponse.DapiAccount account = getDapiAccount(accountID, connection);

            if (account == null) {
                reject("1004", "Unable to find account with id " + accountID, promise);
                return Unit.INSTANCE;
            }

            connection.createWireTransferToExistingBeneficiary(account, receiverID, amount, remark);
            return Unit.INSTANCE;
        }, error -> {
            reject(getErrorCode(error), error, promise);
            return Unit.INSTANCE;
        });
    }

    @ReactMethod
    public void getWireBeneficiaries(String userID, Promise promise) {
        getOperatingConnection(userID, connection -> {
            connection.getWireBeneficiaries(beneficiaries -> {
                resolve(beneficiaries, promise);
                return Unit.INSTANCE;
            }, error -> {
                reject(getErrorCode(error), error, promise);
                return Unit.INSTANCE;
            });
            return Unit.INSTANCE;
        }, error -> {
            reject(getErrorCode(error), error, promise);
            return Unit.INSTANCE;
        });
    }

    @ReactMethod
    public void createWireBeneficiary(String userID, ReadableMap beneficiaryMap, Promise promise) {
        getOperatingConnection(userID, connection -> {
            DapiWireBeneficiary beneficiary = getWireBeneficiary(beneficiaryMap);

            if (beneficiary == null) {
                reject("2012", "Missing beneficiary required field", promise);
                return Unit.INSTANCE;
            }

            connection.createWireBeneficiary(beneficiary, createWireBeneficiary -> {
                resolve(createWireBeneficiary, promise);
                return Unit.INSTANCE;
            }, error -> {
                reject(getErrorCode(error), error, promise);
                return Unit.INSTANCE;
            });

            return Unit.INSTANCE;
        }, error -> {
            reject(getErrorCode(error), error, promise);
            return Unit.INSTANCE;
        });
    }

    @ReactMethod
    public void createACHPullTransfer(
            String userID,
            String description,
            String accountID,
            double amount,
            Promise promise
    ) {
        setTransferCallback(promise);
        getOperatingConnection(userID, connection -> {
            DapiAccountsResponse.DapiAccount account = getDapiAccount(accountID, connection);
            connection.createACHPullTransfer(description, account, amount);
            return Unit.INSTANCE;
        }, error -> {
            reject(getErrorCode(error), error, promise);
            return Unit.INSTANCE;
        });
    }

    @ReactMethod
    public void nymcardLoadFunds(
            String userID,
            String token,
            String accountID,
            double amount,
            Promise promise
    ) {
        setTransferCallback(promise);
        getOperatingConnection(userID, connection -> {
            DapiAccountsResponse.DapiAccount account = getDapiAccount(accountID, connection);
            connection.nymcardLoadFunds(token, account, amount);
            return Unit.INSTANCE;
        }, error -> {
            reject(getErrorCode(error), error, promise);
            return Unit.INSTANCE;
        });
    }

    @ReactMethod
    public void createConnection(String jsonConnectionParameters, Promise promise) {
        DapiConnection.create(jsonConnectionParameters, connection -> {
            WritableMap connectionMap = new WritableNativeMap();
            connectionMap.putString("userID", connection.getUserID());
            connectionMap.putString("clientUserID", connection.getClientUserID());
            connectionMap.putString("bankID", connection.getBankId());
            connectionMap.putString("swiftCode", connection.getSwiftCode());
            connectionMap.putString("bankShortName", connection.getName());
            connectionMap.putString("bankFullName", connection.getFullName());
            connectionMap.putString("country", connection.getCountry());
            connectionMap.putString("fullLogo", connection.getFullLogoPng());
            connectionMap.putString("halfLogo", connection.getHalfLogoPng());
            connectionMap.putString("miniLogo", connection.getMiniLogoPng());
            resolve(connectionMap, promise);
            return Unit.INSTANCE;
        }, error -> {
            reject(getErrorCode(error), error, promise);
            return Unit.INSTANCE;
        });
    }

    @ReactMethod
    public void getConnectionParameters(String userID, Promise promise) {
        getOperatingConnection(userID, connection -> {
            connection.getParameters(params -> {
                resolve(params.toString(), promise);
                return Unit.INSTANCE;
            }, error -> {
                reject(getErrorCode(error), error, promise);
                return Unit.INSTANCE;
            });
            return Unit.INSTANCE;
        }, error -> {
            reject(getErrorCode(error), error, promise);
            return Unit.INSTANCE;
        });
    }


    /**
     * ************ HELPER FUNCTIONS ************
     */

    private <T> void resolve(T data, Promise promise) {
        try {
            if (data instanceof WritableArray || data instanceof WritableMap || data instanceof Boolean || data instanceof String) {
                promise.resolve(data);
            } else {
                promise.resolve(JsonConvert.jsonToReact(convertToJSONObject(data)));
            }

        } catch (JSONException e) {
            e.printStackTrace();
        }
    }

    private <T> void reject(String errorCode, T error, Promise promise) {
        Log.e(TAG, error.toString());
        try {
            if (error instanceof DapiError) {
                DapiError originalError = (DapiError) error;
                JSONObject errorResult = new JSONObject();
                try {
                    errorResult.put(KEY_MESSAGE, originalError.getMessage());
                    errorResult.put(KEY_TYPE, originalError.getType());
                    errorResult.put(KEY_OPERATION_ID, originalError.getOperationID());
                    if(originalError.getCoolDownPeriod() != null) {
                        errorResult.put(KEY_UNIT, originalError.getCoolDownPeriod().getUnit());
                        errorResult.put(KEY_VALUE, originalError.getCoolDownPeriod().getValue());
                    }
                    promise.reject(errorCode, errorResult.toString());
                } catch (Exception e) {
                    e.printStackTrace();
                    HashMap<String, String> map = new HashMap<>();
                    map.put(KEY_MESSAGE, e.getLocalizedMessage());
                    promise.reject(errorCode, new JSONObject(map).toString());
                }
            } else if (error instanceof String) {
                HashMap<String, String> map = new HashMap<>();
                map.put(KEY_MESSAGE, error.toString());
                promise.reject(errorCode, new JSONObject(map).toString());
            } else {
                promise.reject(errorCode, error.toString());
            }

        } catch (Exception e) {
            e.printStackTrace();
            HashMap<String, String> map = new HashMap<>();
            map.put(KEY_MESSAGE, e.getLocalizedMessage());
            promise.reject(errorCode, new JSONObject(map).toString());        }
    }

    private <T> void sendSuccessCallback(T data, Callback callback) {
        callback.invoke(null, data);
    }

    private <T> void sendErrorCallback(T error, Callback callback) {
        callback.invoke(error, null);
    }

    private void sendEvent(ReactContext reactContext,
                           String eventName,
                           @Nullable WritableMap params) {
        reactContext
                .getJSModule(DeviceEventManagerModule.RCTDeviceEventEmitter.class)
                .emit(eventName, params);
    }

    @SuppressWarnings({"ConstantConditions"})
    private DapiConfigurations getConfigurations(ReadableMap configurations) {
        if (configurations == null) {
            return null;
        }
        HashMap<String, Object> extraQueryParameters;
        HashMap<String, Object> extraHeaderFields;
        HashMap<String, Object> extraBody;
        DapiEnvironment environment;
        ReadableArray countries = null;
        boolean showLogos = true;
        boolean showExperimentalBanks = false;
        boolean showCloseButton = true;
        boolean showAddButton = true;
        boolean showTransferSuccessfulResult = true;
        boolean showTransferErrorResult = true;
        String postSuccessfulConnectionLoadingText = "Verifying your account..";
        DapiThemeConfigurations theme;
        DapiLanguage language;

        if (configurations.hasKey("countries")) {
            countries = configurations.getArray("countries");
        }

        if (configurations.hasKey("showLogos")) {
            showLogos = configurations.getBoolean("showLogos");
        }

        if (configurations.hasKey("showExperimentalBanks")) {
            showExperimentalBanks = configurations.getBoolean("showExperimentalBanks");
        }

        if (configurations.hasKey("showCloseButton")) {
            showCloseButton = configurations.getBoolean("showCloseButton");
        }

        if (configurations.hasKey("showAddButton")) {
            showAddButton = configurations.getBoolean("showAddButton");
        }

        if (configurations.hasKey("showTransferSuccessfulResult")) {
            showTransferSuccessfulResult = configurations.getBoolean("showTransferSuccessfulResult");
        }

        if (configurations.hasKey("showTransferErrorResult")) {
            showTransferErrorResult = configurations.getBoolean("showTransferErrorResult");
        }

        if (configurations.hasKey("postSuccessfulConnectionLoadingText")) {
            postSuccessfulConnectionLoadingText = configurations.getString("postSuccessfulConnectionLoadingText");
        }

        if (!configurations.hasKey("endPointExtraQueryItems")) {
            extraQueryParameters = new HashMap<>();
        } else {
            extraQueryParameters = configurations.getMap("endPointExtraQueryItems").toHashMap();
        }

        if (!configurations.hasKey("endPointExtraHeaderFields")) {
            extraHeaderFields = new HashMap<>();
        } else {
            extraHeaderFields = configurations.getMap("endPointExtraHeaderFields").toHashMap();
        }

        if (!configurations.hasKey("endPointExtraBody")) {
            extraBody = new HashMap<>();
        } else {
            extraBody = configurations.getMap("endPointExtraBody").toHashMap();
        }

        if (!configurations.hasKey("theme")) {
            theme = new DapiThemeConfigurations();
        } else {
            theme = getTheme(configurations);
        }

        if (configurations.hasKey("language")) {
            String languageString = configurations.getString("language");
            if (languageString.toLowerCase(Locale.ROOT).equals("ar")) {
                language = DapiLanguage.AR;
            } else {
                language = DapiLanguage.EN;
            }
        } else {
            language = DapiLanguage.EN;
        }

        if (!configurations.hasKey("environment")) {
            environment = DapiEnvironment.PRODUCTION;
        } else {
            String environmentString = configurations.getString("environment");
            if (environmentString.equals("sandbox")) {
                environment = DapiEnvironment.SANDBOX;
            } else {
                environment = DapiEnvironment.PRODUCTION;
            }
        }

        String[] countriesArray;
        if (countries != null) {
            countriesArray = toArray(countries.toArrayList(), String.class);
        } else {
            countriesArray = new String[]{};
        }

        return new DapiConfigurations(
                extraBody,
                extraQueryParameters,
                extraHeaderFields,
                environment,
                countriesArray,
                showLogos,
                showExperimentalBanks,
                showCloseButton,
                showAddButton,
                postSuccessfulConnectionLoadingText,
                showTransferSuccessfulResult,
                showTransferErrorResult,
                theme,
                language
        );
    }

    @NonNull
    private DapiThemeConfigurations getTheme(ReadableMap configurations) {
        DapiThemeConfigurations theme;
        ReadableMap themeMap = configurations.getMap("theme");
        if (themeMap == null) {
            return new DapiThemeConfigurations();
        }
        ReadableMap primaryColor = themeMap.getMap("primaryColor");
        String rawEnforceTheme = themeMap.getString("enforceTheme");
        String lightMode = null;
        String darkMode = null;
        if (primaryColor != null) {
            lightMode = primaryColor.getString("lightMode");
            darkMode = primaryColor.getString("darkMode");
        }
        DapiTheme enforceTheme;
        if (rawEnforceTheme.equals("light")) {
            enforceTheme = DapiTheme.LIGHT;
        } else if (rawEnforceTheme.equals("dark")) {
            enforceTheme = DapiTheme.DARK;
        } else {
            enforceTheme = DapiTheme.DYNAMIC;
        }
        theme = new DapiThemeConfigurations(
                enforceTheme,
                new DapiColor(lightMode, darkMode)
        );
        return theme;
    }

    @SuppressWarnings({"rawtypes", "unchecked", "SameParameterValue"})
    private <T> T[] toArray(Collection collection, Class<T> clazz) {
        T[] array = (T[]) Array.newInstance(clazz, collection.size());
        return ((Collection<T>) collection).toArray(array);
    }

    private DapiBeneficiary getBeneficiary(ReadableMap beneficiaryMap) {

        if (beneficiaryMap == null) {
            return null;
        }

        try {
            ReadableMap linesMap = beneficiaryMap.getMap("linesAddress");
            String line1 = linesMap.getString("line1");
            String line2 = linesMap.getString("line2");
            String line3 = linesMap.getString("line3");
            LinesAddress linesAddress = new LinesAddress(
                    line1,
                    line2,
                    line3
            );
            String accountNumber = beneficiaryMap.getString("accountNumber");
            String name = beneficiaryMap.getString("name");
            String bankName = beneficiaryMap.getString("bankName");
            String swiftCode = beneficiaryMap.getString("swiftCode");
            String iban = beneficiaryMap.getString("iban");
            String phoneNumber = beneficiaryMap.getString("phoneNumber");
            String country = beneficiaryMap.getString("country");
            String branchAddress = beneficiaryMap.getString("branchAddress");
            String branchName = beneficiaryMap.getString("branchName");

            DapiBeneficiary beneficiary = new DapiBeneficiary(
                    linesAddress,
                    accountNumber,
                    name,
                    bankName,
                    swiftCode,
                    iban,
                    country,
                    branchAddress,
                    branchName,
                    phoneNumber
            );

            if (beneficiaryMap.toHashMap().containsKey("nickname")) {
                String nickname = beneficiaryMap.getString("nickname");
                beneficiary.setNickname(nickname);
            }
            return beneficiary;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }

    private DapiWireBeneficiary getWireBeneficiary(ReadableMap beneficiaryMap) {

        if (beneficiaryMap == null) {
            return null;
        }

        try {
            ReadableMap linesMap = beneficiaryMap.getMap("linesAddress");
            String line1 = linesMap.getString("line1");
            String line2 = linesMap.getString("line2");
            String line3 = linesMap.getString("line3");
            LinesAddress linesAddress = new LinesAddress(
                    line1,
                    line2,
                    line3
            );

            String name = beneficiaryMap.getString("name");
            String firstName = beneficiaryMap.getString("firstName");
            String lastName = beneficiaryMap.getString("lastName");
            String nickname = beneficiaryMap.getString("nickname");
            String city = beneficiaryMap.getString("city");
            String state = beneficiaryMap.getString("state");
            String country = beneficiaryMap.getString("country");
            String zipCode = beneficiaryMap.getString("zipCode");
            String receiverType = beneficiaryMap.getString("receiverType");
            String receiverAccountType = beneficiaryMap.getString("receiverAccountType");
            String routingNumber = beneficiaryMap.getString("routingNumber");
            String accountNumber = beneficiaryMap.getString("accountNumber");


            DapiWireBeneficiary beneficiary = new DapiWireBeneficiary(
                    name,
                    firstName,
                    lastName,
                    nickname,
                    linesAddress,
                    city,
                    state,
                    country,
                    zipCode,
                    receiverType,
                    receiverAccountType,
                    routingNumber,
                    accountNumber
            );

            return beneficiary;
        } catch (Exception e) {
            e.printStackTrace();
            return null;
        }
    }


    private DapiAccountsResponse.DapiAccount getDapiAccount(String accountID, DapiConnection connection) {

        if (accountID == null || connection == null) {
            return null;
        }

        for (DapiAccountsResponse.DapiAccount account : connection.getAccounts()) {
            if (account.getId().equals(accountID)) {
                return account;
            }
        }
        return null;
    }

    private DapiCardsResponse.DapiCard getDapiCard(String cardID, DapiConnection connection) {

        if (cardID == null || connection == null) {
            return null;
        }

        for (DapiCardsResponse.DapiCard card : connection.getCards()) {
            if (card.getId().equals(cardID)) {
                return card;
            }
        }
        return null;
    }

    private void getOperatingConnection(String userID, Function1<? super DapiConnection, Unit> onSuccess, Function1<? super DapiError, Unit> onFailure) {
        Dapi.getConnections(connections -> {
            for (DapiConnection connection : connections) {
                if (connection.getUserID().equals(userID)) {
                    onSuccess.invoke(connection);
                    break;
                }
            }
            return Unit.INSTANCE;
        }, error -> {
            onFailure.invoke(error);
            return Unit.INSTANCE;
        });
    }

    private void setConnectCallback() {
        Dapi.setConnectCallback(new DapiConnectCallback() {
            @Override
            public void onConnectionSuccessful(@NonNull DapiConnectResult.Success result) {
                WritableMap params = Arguments.createMap();
                try {
                    params.putMap("connection", JsonConvert.jsonToReact(convertToJSONObject(result.getConnection())));
                } catch (JSONException e) {
                    e.printStackTrace();
                }
                sendEvent(getReactApplicationContext(), EVENT_CONNECT_SUCCESSFUL, params);
            }

            @Override
            public void onConnectionFailure(@NonNull DapiConnectResult.Error result) {
                WritableMap params = Arguments.createMap();
                params.putString("bankID", result.getBankID());
                params.putString("error", result.getError().getMessage());
                sendEvent(getReactApplicationContext(), EVENT_CONNECT_FAILURE, params);
            }

            @Override
            public void onBankRequest(@NonNull DapiConnectResult.BankRequest result) {
                WritableMap params = Arguments.createMap();
                params.putString("bankName", result.getBankName());
                params.putString("iban", result.getIban());
                sendEvent(getReactApplicationContext(), EVENT_CONNECT_BANK_REQUEST, params);
            }

            @Override
            public void onDismissed() {
                sendEvent(getReactApplicationContext(), EVENT_CONNECT_DISMISSED, null);
            }
        });
    }

    private void setTransferCallback(Promise promise) {
        Dapi.setTransferCallback(new DapiTransferCallback() {
            @Override
            public void onTransferSuccess(@NonNull DapiTransferResult.Success result) {
                HashMap<String, Object> successfulTransferMap = new HashMap<>();
                successfulTransferMap.put("account", result.getAccount().getId());
                successfulTransferMap.put("amount", result.getAmount());
                successfulTransferMap.put("operationID", result.getOperationID());
                successfulTransferMap.put("remark", result.getRemark());
                successfulTransferMap.put("reference", result.getReference());
                resolve(successfulTransferMap, promise);
            }

            @Override
            public void onTransferFailure(@NonNull DapiTransferResult.Error result) {
                JSONObject errorObject = new JSONObject();
                try {
                    errorObject.put(KEY_MESSAGE, result.getError().getMessage());
                    errorObject.put(KEY_TYPE, result.getError().getType());
                    errorObject.put(KEY_OPERATION_ID, result.getError().getOperationID());
                    errorObject.put(KEY_ACCOUNT, result.getAccount().getId());
                    if(result.getError().getCoolDownPeriod() != null) {
                        errorObject.put(KEY_UNIT, result.getError().getCoolDownPeriod().getUnit());
                        errorObject.put(KEY_VALUE, result.getError().getCoolDownPeriod().getValue());
                    }
                } catch (Exception e) {
                    e.printStackTrace();
                    reject(getErrorCode(result.getError()), result.getError(), promise);
                }
                reject(getErrorCode(result.getError()), errorObject, promise);
            }

            @Override
            public void willTransferAmount(@NonNull DapiTransferResult.PreTransfer result) {
                WritableMap params = Arguments.createMap();
                params.putDouble("amount", result.getAmount());
                params.putString("account", result.getAccount().getId());
                sendEvent(getReactApplicationContext(), EVENT_DAPI_UI_WILL_TRANSFER, params);
            }

            @Override
            public void onUiDismissed() {
                sendEvent(getReactApplicationContext(), EVENT_DAPI_TRANSFER_UI_DISMISSED, null);
            }
        });
    }

    private JSONObject convertToJSONObject(Object object) {
        Gson gson = new Gson();
        String jsonString = gson.toJson(object);
        try {
            return new JSONObject(jsonString);
        } catch (Exception e) {
            return new JSONObject();
        }
    }

    private String getErrorCode(DapiError error) {
        switch (error.getType()) {
            case DapiError.LOCAL_STORE_ERROR:
                return "1000";
            case DapiError.USER_CANCELLED:
                return "1003";
            case DapiError.INVALID_CREDENTIALS:
            case DapiError.INVALID_CONNECTION:
                return "2000";
            case DapiError.UNKNOWN_ERROR:
                return "2002";
            case DapiError.USER_ALREADY_LOGGED_IN:
                return "2004";
            case DapiError.INSUFFICIENT_FUNDS:
                return "2005";
            case DapiError.BENEFICIARY_NOT_ACTIVATED:
                return "2006";
            case DapiError.SESSION_EXPIRED:
                return "2007";
            case DapiError.ACCOUNT_LOCKED:
                return "2008";
            case DapiError.SESSION_INVALIDATED:
                return "2011";
            case DapiError.INVALID_BENEFICIARY:
                return "2012";
            default:
                return "0";
        }
    }


}
