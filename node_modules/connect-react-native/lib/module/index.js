import NativeInterface from './internal/nativeInterface';
import { DapiEnvironment } from './internal/types';
export class DapiError extends Error {
  constructor(message, type, operationID, account, beneficiaryCoolDownPeriod) {
    super(message);
    this.name = 'DapiError';
    this.type = type;
    this.operationID = operationID;
    this.account = account;
    this.beneficiaryCoolDownPeriod = beneficiaryCoolDownPeriod;
  }
}
export class DapiConfigurations {
  constructor(countries, environment = DapiEnvironment.production) {
    this.environment = environment;
    this.countries = countries;
  }
}
class TransferResponse {
  constructor(amount, operationID, accountID, remark, reference) {
    this.accountID = accountID;
    this.amount = amount;
    this.operationID = operationID;
    this.remark = remark;
    this.reference = reference;
  }
}
export class DapiThemeConfigurations {
  constructor(enforceTheme, primaryColor) {
    this.enforceTheme = enforceTheme;
    this.primaryColor = primaryColor;
  }
}
export class DapiConnection {
  get clientUserID() {
    return this._clientUserID;
  }
  get userID() {
    return this._userID;
  }
  get bankID() {
    return this._bankID;
  }
  get swiftCode() {
    return this._swiftCode;
  }
  get country() {
    return this._country;
  }
  get bankShortName() {
    return this._bankShortName;
  }
  get bankFullName() {
    return this._bankFullName;
  }
  get fullLogo() {
    return this._fullLogo;
  }
  get halfLogo() {
    return this._halfLogo;
  }
  get miniLogo() {
    return this._miniLogo;
  }
  static async create(jsonConnectionDetails) {
    var promise = new Promise(async (resolve, reject) => {
      const isStarted = await Dapi.instance.isStarted();
      if (!isStarted) {
        let error = new DapiError("Dapi SDK is not started yet. It's not permitted to call create() (or any other method) on Dapi SDK unless started.");
        reject(error);
        return;
      }
      NativeInterface.createConnection(jsonConnectionDetails).then(newJSONConnection => {
        Dapi.instance.getConnections().then(connections => {
          let isResolved = false;
          for (let index = 0; index < connections.length; index++) {
            const element = connections[index];
            if (element.userID === newJSONConnection.userID) {
              isResolved = true;
              resolve(element);
              break;
            }
          }
          if (!isResolved) {
            let error = new DapiError("matchingConnection is undefined");
            reject(error);
          }
        }).catch(getConnectionsError => {
          reject(getConnectionsError);
        });
      }).catch(error => {
        let {
          message,
          type,
          operationID
        } = errorInfo(error);
        reject(new DapiError(message, type, operationID));
      });
    });
    return promise;
  }
  constructor(clientUserID, userID, bankID, swiftCode, country, bankShortName, bankFullName, fullLogo, halfLogo, miniLogo) {
    this._clientUserID = clientUserID;
    this._userID = userID;
    this._bankID = bankID;
    this._swiftCode = swiftCode;
    this._country = country;
    this._bankShortName = bankShortName;
    this._bankFullName = bankFullName;
    this._fullLogo = fullLogo;
    this._halfLogo = halfLogo;
    this._miniLogo = miniLogo;
  }
  async presentAccountSelection() {
    return new Promise(async (resolve, reject) => {
      NativeInterface.presentAccountSelection(this.userID).then(response => {
        resolve(response);
      }).catch(error => {
        let {
          message,
          type,
          operationID
        } = errorInfo(error);
        reject(new DapiError(message, type, operationID));
      });
    });
  }
  getParameters() {
    return new Promise(async (resolve, reject) => {
      NativeInterface.getConnectionParameters(this.userID).then(response => {
        resolve(response);
      }).catch(error => {
        let {
          message,
          type,
          operationID
        } = errorInfo(error);
        reject(new DapiError(message, type, operationID));
      });
    });
  }
  getIdentity() {
    return new Promise(async (resolve, reject) => {
      NativeInterface.getIdentity(this.userID).then(response => {
        resolve(response);
      }).catch(error => {
        let {
          message,
          type,
          operationID
        } = errorInfo(error);
        reject(new DapiError(message, type, operationID));
      });
    });
  }
  getAccounts() {
    return new Promise(async (resolve, reject) => {
      NativeInterface.getAccounts(this.userID).then(response => {
        resolve(response);
      }).catch(error => {
        let {
          message,
          type,
          operationID
        } = errorInfo(error);
        reject(new DapiError(message, type, operationID));
      });
    });
  }
  getCards() {
    return new Promise(async (resolve, reject) => {
      NativeInterface.getCards(this.userID).then(response => {
        resolve(response);
      }).catch(error => {
        let {
          message,
          type,
          operationID
        } = errorInfo(error);
        reject(new DapiError(message, type, operationID));
      });
    });
  }
  getTransactionsForAccount(account, startDate, endDate, type) {
    return new Promise(async (resolve, reject) => {
      NativeInterface.getTransactionsForAccount(this.userID, account.id, startDate.getTime(), endDate.getTime(), type).then(response => {
        resolve(response);
      }).catch(error => {
        let {
          message,
          type,
          operationID
        } = errorInfo(error);
        reject(new DapiError(message, type, operationID));
      });
    });
  }
  getTransactionsForCard(card, startDate, endDate, type) {
    return new Promise(async (resolve, reject) => {
      NativeInterface.getTransactionsForCard(this.userID, card.id, startDate.getTime(), endDate.getTime(), type).then(response => {
        resolve(response);
      }).catch(error => {
        let {
          message,
          type,
          operationID
        } = errorInfo(error);
        reject(new DapiError(message, type, operationID));
      });
    });
  }
  getAccountsMetadata() {
    return new Promise(async (resolve, reject) => {
      NativeInterface.getAccountsMetadata(this.userID).then(response => {
        resolve(response);
      }).catch(error => {
        let {
          message,
          type,
          operationID
        } = errorInfo(error);
        reject(new DapiError(message, type, operationID));
      });
    });
  }
  delete() {
    return new Promise(async (resolve, reject) => {
      NativeInterface.delete(this.userID).then(() => {
        resolve();
      }).catch(error => {
        let {
          message,
          type,
          operationID
        } = errorInfo(error);
        reject(new DapiError(message, type, operationID));
      });
    });
  }
  createBeneficiary(beneficiary) {
    return new Promise(async (resolve, reject) => {
      NativeInterface.createBeneficiary(this.userID, beneficiary).then(response => {
        resolve(response);
      }).catch(error => {
        let {
          message,
          type,
          operationID,
          unit,
          value
        } = errorInfo(error);
        reject(new DapiError(message, type, operationID, undefined, {
          value,
          unit
        }));
      });
    });
  }
  getBeneficiaries() {
    return new Promise(async (resolve, reject) => {
      NativeInterface.getBeneficiaries(this.userID).then(response => {
        resolve(response);
      }).catch(error => {
        let {
          message,
          type,
          operationID
        } = errorInfo(error);
        reject(new DapiError(message, type, operationID));
      });
    });
  }
  async createTransfer(fromAccount, toBeneficiary, amount, remark) {
    return new Promise(async (resolve, reject) => {
      await NativeInterface.createTransfer(this.userID, fromAccount ? fromAccount.id : null, toBeneficiary, amount, remark).then(response => {
        let accountID = response.account;
        let amnt = response.amount;
        let operationID = response.operationID;
        let resultRemark = response.remark;
        let reference = response.reference;
        resolve(new TransferResponse(amnt, operationID, accountID, resultRemark, reference));
      }).catch(error => {
        let {
          message,
          type,
          operationID,
          account,
          unit,
          value
        } = errorInfo(error);
        reject(new DapiError(message, type, operationID, account, {
          value,
          unit
        }));
      });
    });
  }
  async createTransferToExistingBeneficiary(fromAccount, toBeneficiaryID, amount, remark) {
    return new Promise(async (resolve, reject) => {
      await NativeInterface.createTransferToExistingBeneficiary(this.userID, fromAccount.id, toBeneficiaryID, amount, remark).then(response => {
        let accountID = response.account;
        let amnt = response.amount;
        let operationID = response.operationID;
        let resultRemark = response.remark;
        let reference = response.reference;
        resolve(new TransferResponse(amnt, operationID, accountID, resultRemark, reference));
      }).catch(error => {
        let {
          message,
          type,
          operationID,
          account,
          unit,
          value
        } = errorInfo(error);
        reject(new DapiError(message, type, operationID, account, {
          value,
          unit
        }));
      });
    });
  }
  createWireBeneficiary(beneficiary) {
    return new Promise(async (resolve, reject) => {
      NativeInterface.createWireBeneficiary(this.userID, beneficiary).then(response => {
        resolve(response);
      }).catch(error => {
        let {
          message,
          type,
          operationID,
          unit,
          value
        } = errorInfo(error);
        reject(new DapiError(message, type, operationID, undefined, {
          value,
          unit
        }));
      });
    });
  }
  getWireBeneficiaries() {
    return new Promise(async (resolve, reject) => {
      NativeInterface.getWireBeneficiaries(this.userID).then(response => {
        resolve(response);
      }).catch(error => {
        let {
          message,
          type,
          operationID
        } = errorInfo(error);
        reject(new DapiError(message, type, operationID));
      });
    });
  }
  async createWireTransfer(toBeneficiary, fromAccount, amount, remark) {
    return new Promise(async (resolve, reject) => {
      await NativeInterface.createWireTransfer(this.userID, toBeneficiary, fromAccount ? fromAccount.id : null, amount, remark).then(response => {
        let accountID = response.account;
        let amnt = response.amount;
        let operationID = response.operationID;
        let resultRemark = response.remark;
        let reference = response.reference;
        resolve(new TransferResponse(amnt, operationID, accountID, resultRemark, reference));
      }).catch(error => {
        let {
          message,
          type,
          operationID,
          account,
          unit,
          value
        } = errorInfo(error);
        reject(new DapiError(message, type, operationID, account, {
          value,
          unit
        }));
      });
    });
  }
  async createWireTransferToExistingBeneficiary(fromAccount, toBeneficiaryID, amount, remark) {
    return new Promise(async (resolve, reject) => {
      await NativeInterface.createWireTransferToExistingBeneficiary(this.userID, fromAccount.id, toBeneficiaryID, amount, remark).then(response => {
        let accountID = response.account;
        let amnt = response.amount;
        let operationID = response.operationID;
        let resultRemark = response.remark;
        let reference = response.reference;
        resolve(new TransferResponse(amnt, operationID, accountID, resultRemark, reference));
      }).catch(error => {
        let {
          message,
          type,
          operationID,
          account,
          unit,
          value
        } = errorInfo(error);
        reject(new DapiError(message, type, operationID, account, {
          value,
          unit
        }));
      });
    });
  }
  async createACHPullTransfer(description, fromAccount, amount) {
    return new Promise(async (resolve, reject) => {
      await NativeInterface.createACHPullTransfer(this.userID, description, fromAccount ? fromAccount.id : null, amount).then(response => {
        let accountID = response.account;
        let amnt = response.amount;
        let operationID = response.operationID;
        resolve(new TransferResponse(amnt, operationID, accountID, undefined, undefined));
      }).catch(error => {
        let {
          message,
          type,
          operationID,
          account,
          unit,
          value
        } = errorInfo(error);
        reject(new DapiError(message, type, operationID, account, {
          value,
          unit
        }));
      });
    });
  }
  async nymcardLoadFunds(token, fromAccount, amount) {
    return new Promise(async (resolve, reject) => {
      await NativeInterface.nymcardLoadFunds(this.userID, token, fromAccount ? fromAccount.id : null, amount).then(response => {
        let accountID = response.account;
        let amnt = response.amount;
        let operationID = response.operationID;
        let remark = response.remark;
        let reference = response.reference;
        resolve(new TransferResponse(amnt, operationID, accountID, remark, reference));
      }).catch(error => {
        let {
          message,
          type,
          operationID,
          account,
          unit,
          value
        } = errorInfo(error);
        reject(new DapiError(message, type, operationID, account, {
          value,
          unit
        }));
      });
    });
  }
}
export class DapiPair {
  constructor(code, name) {
    this.code = code;
    this.name = name;
  }
}
export class DapiLineAddress {
  constructor(line1, line2, line3) {
    this.line1 = line1;
    this.line2 = line2;
    this.line3 = line3;
  }
}
export class DapiBeneficiary {
  constructor(linesAddress, accountNumber, name, bankName, swiftCode, iban, phoneNumber, country, branchAddress, branchName, nickname) {
    this.linesAddress = linesAddress;
    this.accountNumber = accountNumber;
    this.name = name;
    this.bankName = bankName;
    this.swiftCode = swiftCode;
    this.iban = iban;
    this.phoneNumber = phoneNumber;
    this.country = country;
    this.branchAddress = branchAddress;
    this.branchName = branchName;
    this.nickname = nickname;
  }
}
export class DapiWireBeneficiary {
  constructor(linesAddress, name, firstName, lastName, nickname, city, state, country, zipCode, receiverType, receiverAccountType, routingNumber, accountNumber) {
    this.linesAddress = linesAddress;
    this.name = name;
    this.firstName = firstName;
    this.lastName = lastName;
    this.nickname = nickname;
    this.city = city;
    this.state = state;
    this.country = country;
    this.zipCode = zipCode;
    this.receiverType = receiverType;
    this.receiverAccountType = receiverAccountType;
    this.routingNumber = routingNumber;
    this.accountNumber = accountNumber;
  }
}
export class DapiAccount {
  constructor(balance, iban, number, currency, type, id, name) {
    this.balance = balance;
    this.iban = iban;
    this.number = number;
    this.currency = currency;
    this.type = type;
    this.id = id;
    this.name = name;
  }
}
export class DapiCardBalance {
  constructor(amountDue, availableBalance, outstandingBalance, dueDate) {
    this.amountDue = amountDue;
    this.availableBalance = availableBalance;
    this.outstandingBalance = outstandingBalance;
    this.dueDate = dueDate;
  }
}
export class DapiCard {
  constructor(balance, cardNumber, creditLimit, currency, expiryDate, id, name, status, type) {
    this.balance = balance;
    this.cardNumber = cardNumber;
    this.creditLimit = creditLimit;
    this.currency = currency;
    this.expiryDate = expiryDate;
    this.id = id;
    this.name = name;
    this.status = status;
    this.type = type;
  }
}
export default class Dapi {
  static _instance = new Dapi();
  static get instance() {
    return this._instance;
  }
  constructor() {}
  start(appKey, clientUserID, configurations) {
    return new Promise(async (resolve, reject) => {
      NativeInterface.start(appKey, clientUserID, configurations).then(response => {
        resolve(response);
      }).catch(error => {
        let {
          message,
          type,
          operationID
        } = errorInfo(error);
        reject(new DapiError(message, type, operationID));
      });
    });
  }
  isStarted() {
    return NativeInterface.isStarted();
  }
  presentConnect(bankID) {
    NativeInterface.presentConnect(bankID);
  }
  setClientUserID(clientUserID) {
    NativeInterface.setClientUserID(clientUserID);
  }
  clientUserID() {
    return NativeInterface.clientUserID();
  }
  setConfigurations(configurations) {
    NativeInterface.setConfigurations(configurations);
  }
  configurations() {
    return NativeInterface.configurations();
  }
  dismissConnect() {
    NativeInterface.dismissConnect();
  }
  async getConnections() {
    return new Promise(async (resolve, reject) => {
      await NativeInterface.getConnections().then(response => {
        let connections = [];
        for (let i = 0; i < response.length; i++) {
          let currentConnection = response[i];
          let connection = new DapiConnection(currentConnection.clientUserID, currentConnection.userID, currentConnection.bankID, currentConnection.swiftCode, currentConnection.country, currentConnection.bankShortName, currentConnection.bankFullName, currentConnection.fullLogo, currentConnection.halfLogo, currentConnection.miniLogo);
          connections.push(connection);
        }
        resolve(connections);
      }).catch(error => {
        let {
          message,
          type,
          operationID
        } = errorInfo(error);
        reject(new DapiError(message, type, operationID));
      });
    });
  }
}
function errorInfo(error) {
  let json = JSON.parse(error.message);
  let message;
  let type;
  let operationID;
  let account;
  let unit;
  let value;
  if (json.hasOwnProperty("message")) {
    message = json.message;
  }
  if (json.hasOwnProperty("type")) {
    type = json.type;
  }
  if (json.hasOwnProperty("operationID")) {
    operationID = json.operationID;
  }
  if (json.hasOwnProperty("account")) {
    account = json.account;
  }
  if (json.hasOwnProperty("unit")) {
    unit = json.unit;
  }
  if (json.hasOwnProperty("value")) {
    value = json.value;
  }
  return {
    message: message,
    type: type,
    operationID: operationID,
    account: account,
    unit: unit,
    value: value
  };
}
export * from './internal/types';
//# sourceMappingURL=index.js.map